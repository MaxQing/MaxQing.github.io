{"title":"Expression in C++ (C++ primer 5th)","slug":"Expression in C++","date":"2021-04-19T12:28:22.077Z","updated":"2021-04-19T12:41:54.196Z","comments":true,"excerpt":"","content":"<h1 id=\"Expression-in-C\"><a href=\"#Expression-in-C\" class=\"headerlink\" title=\"Expression in C++\"></a>Expression in C++</h1><h2 id=\"1-1-Basic\"><a href=\"#1-1-Basic\" class=\"headerlink\" title=\"1.1 Basic\"></a>1.1 Basic</h2><h3 id=\"1-1-1-Concepts\"><a href=\"#1-1-1-Concepts\" class=\"headerlink\" title=\"1.1.1 Concepts\"></a>1.1.1 Concepts</h3><p>unary operator: acting on single operand, like as <em>Address operator</em> <code>&amp;</code>, <em>dereference</em> <code>*</code>.</p>\n<p>binary operator: acting on double operands, like as <em>plus operator</em> <code>+</code>, <em>Assignment operator</em> <code>=</code>.</p>\n<p>ternary operator: the same, acting on three operands. <code>?:</code>.</p>\n<p>(<em>For complicated expression with multiple operator, we must clear three things,</em></p>\n<p><strong>precedence</strong>, <strong>associativity</strong> <em>and</em> <strong>order of evaluation</strong>.)</p>\n<h4 id=\"rvalue-and-lvalue\"><a href=\"#rvalue-and-lvalue\" class=\"headerlink\" title=\"rvalue and lvalue\"></a>rvalue and lvalue</h4><p>(historical reason: rvalue can’t be on the right side of the assignment operator, but lvalue can be. )</p>\n<p><strong>When an object is used  as an rvalue, we use the value of the object.</strong></p>\n<p><strong>When an object is used as an lvalue, we use the identifier of the object.(address in memory)</strong></p>\n<h3 id=\"1-1-2-Precedence-and-Associativity\"><a href=\"#1-1-2-Precedence-and-Associativity\" class=\"headerlink\" title=\"1.1.2 Precedence and Associativity\"></a>1.1.2 Precedence and Associativity</h3><p>compound expression: an expression containing two or more operators.</p>\n\n    <pre><code class=\"lang-c++\"><span class=\"hljs-symbol\">6 </span>+ <span class=\"hljs-number\">3</span> * <span class=\"hljs-number\">4</span> / <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>\n</code></pre>\n<p>(<em>pay attention to precedence and associativity.</em>)</p>\n<p><strong>brackets ignore precedence and associativity.</strong></p>\n\n    <pre><code class=\"lang-c++\"><span class=\"hljs-comment\">(6 + 3)</span> * <span class=\"hljs-comment\">(4 / 2 + 2)</span>    <span class=\"hljs-comment\">//36</span>\n<span class=\"hljs-comment\">((6 + 3)</span> * <span class=\"hljs-number\">4</span>) / <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>    <span class=\"hljs-comment\">//20</span>\n</code></pre>\n<h3 id=\"1-1-3-Order-Of-Evaluation\"><a href=\"#1-1-3-Order-Of-Evaluation\" class=\"headerlink\" title=\"1.1.3 Order Of Evaluation\"></a>1.1.3 Order Of Evaluation</h3><p>For those operators that don’t specify the execution order, if the expression points to and modifies the same object, an error will be raised  and undefined behavior.</p>\n\n    <pre><code class=\"lang-c++\"><span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;\nstd::cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span> &lt;&lt; i++ &lt;&lt; endl;    <span class=\"hljs-comment\">//undefined behavior</span>\n</code></pre>\n<p>Above the same precedence, the order of evaluation is from left to right.</p>\n<h2 id=\"1-2-Arithmetic-Operator\"><a href=\"#1-2-Arithmetic-Operator\" class=\"headerlink\" title=\"1.2 Arithmetic Operator\"></a>1.2 Arithmetic Operator</h2><p>The precedence of arithmetic operator(from high to low):</p>\n<ul>\n<li>(as unary op) <code>+</code> , <code>-</code> (+expr / -expr)</li>\n<li>(as binary op) <code>*</code> , <code>/</code>,  <code>%</code> (<strong>Mod</strong>)</li>\n<li>(as binary op) <code>+</code>, <code>-</code></li>\n</ul>\n<p><strong>Before the expression is evaluated, the operands of the small integer type will be promoted to the larger integer type.</strong></p>\n\n    <pre><code class=\"lang-c++\"><span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">1024</span>;\n<span class=\"hljs-built_in\">int</span> k = -i;        //the value <span class=\"hljs-keyword\">of</span> k <span class=\"hljs-keyword\">is</span> -<span class=\"hljs-number\">1024</span>\n<span class=\"hljs-built_in\">bool</span> b = <span class=\"hljs-literal\">true</span>;\n// b-&gt;<span class=\"hljs-built_in\">int</span> <span class=\"hljs-number\">1</span>-&gt;<span class=\"hljs-built_in\">int</span> -<span class=\"hljs-number\">1</span>-&gt;<span class=\"hljs-literal\">true</span>\n<span class=\"hljs-built_in\">bool</span> b2 = -b;    //the value <span class=\"hljs-keyword\">of</span> b2 <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">true</span>.\n</code></pre>\n<p><strong>For mod operator, the both sides must be integer.</strong></p>\n\n    <pre><code class=\"lang-c++\"><span class=\"hljs-built_in\">int</span> <span class=\"hljs-keyword\">val</span> = <span class=\"hljs-number\">43</span>;\ndouble d_val = <span class=\"hljs-number\">3.34</span>;\n<span class=\"hljs-keyword\">val</span> % <span class=\"hljs-number\">11</span>;        <span class=\"hljs-comment\">//result is 10</span>\n<span class=\"hljs-keyword\">val</span> % d_val;    <span class=\"hljs-comment\">//error</span>\n</code></pre>\n<p>(<em>In C++11, quotient must be zero-truncating.</em>)</p>\n<h2 id=\"1-3-Logic-and-Relational-Operator\"><a href=\"#1-3-Logic-and-Relational-Operator\" class=\"headerlink\" title=\"1.3 Logic and Relational Operator\"></a>1.3 Logic and Relational Operator</h2><p>precedence like this(high -&gt; low):</p>\n<ul>\n<li>not <code>!</code></li>\n<li>relational operator(<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>)</li>\n<li>relational op(<code>==</code>, <code>!=</code>)</li>\n<li>and <code>&amp;&amp;</code>  or <code>||</code></li>\n</ul>\n<p><strong>Short-circuit evaluation: AND operator and OR operator will calculate the value of the right operand if and only if  the left operand can’t determine the result of the whole expression.</strong></p>\n\n    <pre><code class=\"lang-c++\">const char *<span class=\"hljs-keyword\">cp</span> = <span class=\"hljs-string\">&quot;Hello, world.&quot;</span><span class=\"hljs-comment\">;</span>\nif (<span class=\"hljs-keyword\">cp</span> &amp;&amp; *<span class=\"hljs-keyword\">cp</span>)    //ensure <span class=\"hljs-keyword\">cp</span> is available <span class=\"hljs-keyword\">and</span> not pointer to <span class=\"hljs-string\">&#x27;\\n&#x27;</span>\n</code></pre>\n<h2 id=\"1-4-Assignment-Operator\"><a href=\"#1-4-Assignment-Operator\" class=\"headerlink\" title=\"1.4 Assignment Operator\"></a>1.4 Assignment Operator</h2><p><strong>The left operand of the assignment operator must be a modifiable lvalue.</strong></p>\n\n    <pre><code class=\"lang-c++\">int a <span class=\"hljs-built_in\">=</span> <span class=\"hljs-number\">1</span>, b <span class=\"hljs-built_in\">=</span> <span class=\"hljs-number\">2</span>, c <span class=\"hljs-built_in\">=</span> <span class=\"hljs-number\">3</span>;\nconst int ci <span class=\"hljs-built_in\">=</span> a;\n\n// the following statements <span class=\"hljs-built_in\">all</span> <span class=\"hljs-keyword\">is</span> illegal.\n\n<span class=\"hljs-number\">1024</span> <span class=\"hljs-built_in\">=</span> c;    //literal <span class=\"hljs-keyword\">is</span> rvalue.\na + b <span class=\"hljs-built_in\">=</span> c;    //arithmetic expression <span class=\"hljs-keyword\">is</span> rvalue.\nci <span class=\"hljs-built_in\">=</span> b;        //ci <span class=\"hljs-keyword\">is</span> const(lvalue).\n</code></pre>\n<p>(<em>Meanwhile, the assignment operator satisfies the right associative law.</em>)</p>\n\n    <pre><code class=\"lang-c++\"><span class=\"hljs-built_in\">int</span> ival;\n<span class=\"hljs-built_in\">int</span> temp;\nival = temp = <span class=\"hljs-number\">3</span>;\n\n<span class=\"hljs-built_in\">int</span> <span class=\"hljs-keyword\">var</span>, *pvar;\n<span class=\"hljs-keyword\">var</span> = pvar = <span class=\"hljs-number\">0</span>;        <span class=\"hljs-comment\">//this is wrong.</span>\n\n<span class=\"hljs-built_in\">string</span> s1, s2;\ns1 = s2 = <span class=\"hljs-string\">&quot;this can be right.&quot;</span>;\n</code></pre>\n<h2 id=\"1-5-Increment-and-Decrement-Operator\"><a href=\"#1-5-Increment-and-Decrement-Operator\" class=\"headerlink\" title=\"1.5 Increment and Decrement Operator\"></a>1.5 Increment and Decrement Operator</h2><p>These two operators(<code>--</code>, <code>++</code>) provide a concise form for the addition and subtraction of object.</p>\n<p><strong>Note the location of these operators.</strong></p>\n\n    <pre><code class=\"lang-c++\"><span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">1</span>;\n<span class=\"hljs-built_in\">int</span> j = <span class=\"hljs-number\">0</span>;\n\n<span class=\"hljs-comment\">//in the front of object.</span>\nj = ++i;        <span class=\"hljs-comment\">//j = 2, i = 2 </span>\n\n<span class=\"hljs-comment\">//behind the object.</span>\nj = i++;        <span class=\"hljs-comment\">//j = 2, i = 3</span>\n</code></pre>\n<p>(<em>increment and decrement operator must act on lvalue.</em>)</p>\n<p>(<em>avoiding using post form  most of time</em>.) </p>\n<h2 id=\"1-6-Member-Access-Operator\"><a href=\"#1-6-Member-Access-Operator\" class=\"headerlink\" title=\"1.6 Member Access Operator\"></a>1.6 Member Access Operator</h2><p>point operator and arrow operator can access the member of object.</p>\n<p><code>ptr-&gt;mem</code> equals <code>(*ptr).mem</code>:</p>\n\n    <pre><code class=\"lang-c++\">std::string s1 = <span class=\"hljs-string\">&quot;a string&quot;</span>, *p = &amp;s1;\n<span class=\"hljs-keyword\">auto</span> n = s1.<span class=\"hljs-built_in\">size</span>();\nn = (*p).<span class=\"hljs-built_in\">size</span>();\nn = p-&gt;<span class=\"hljs-built_in\">size</span>();    <span class=\"hljs-comment\">//equals (*p).size()</span>\n</code></pre>\n<pre><code>iter++-&gt;empty();\n(*iter++).empty();\n</code></pre>\n<h2 id=\"1-7-Conditional-Operator\"><a href=\"#1-7-Conditional-Operator\" class=\"headerlink\" title=\"1.7 Conditional Operator\"></a>1.7 Conditional Operator</h2><p><code>condition ? expr1 : expr2</code></p>\n<p>a simple example:</p>\n\n    <pre><code class=\"lang-c++\"><span class=\"hljs-attribute\">string final_grade</span> = (grade &lt; 60) ? <span class=\"hljs-string\">&quot;failed&quot;</span> : <span class=\"hljs-string\">&quot;pass&quot;</span>;\n</code></pre>\n<h2 id=\"1-8-Bitwise-Operator\"><a href=\"#1-8-Bitwise-Operator\" class=\"headerlink\" title=\"1.8 Bitwise Operator\"></a>1.8 Bitwise Operator</h2><p>Acting on integer object(or <code>bitset</code>).</p>\n<ul>\n<li><code>~</code> -&gt; <strong>bit inversion</strong></li>\n<li><code>&lt;&lt;</code> -&gt; <strong>left shift</strong></li>\n<li><code>&gt;&gt;</code> -&gt; <strong>right shift</strong></li>\n<li><code>&amp;</code> -&gt; <strong>bit and</strong></li>\n<li><code>^</code> -&gt; <strong>bit xor</strong></li>\n<li><code>|</code> -&gt; <strong>bit or</strong></li>\n</ul>\n<p>(<em>It is strongly recommended to use bitwise operators only for handing <strong>unsigned</strong> types.</em>)</p>\n<h2 id=\"1-9-Size-of-Operator\"><a href=\"#1-9-Size-of-Operator\" class=\"headerlink\" title=\"1.9 Size of Operator\"></a>1.9 Size of Operator</h2><p><strong>The <code>sizeof</code> operator returns the number of bytes occupied by an expression or a type name.</strong></p>\n\n    <pre><code class=\"lang-c++\">//a trick\n//require the number of<span class=\"hljs-built_in\"> array </span>contained.\nconstexpr size_t sz = sizeof(ia) / sizeof(*ia);<span class=\"hljs-built_in\">\nint </span>arr2[zs];\n</code></pre>\n\n    <pre><code class=\"lang-c++\">Sales_data sales, *p;\n<span class=\"hljs-keyword\">char</span> temp_c = <span class=\"hljs-string\">&#x27;A&#x27;</span>;\nSales_data &amp;refer_sales = sales;\n<span class=\"hljs-keyword\">int</span> arr[<span class=\"hljs-number\">10</span>];\ncout &lt;&lt; <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(temp_c) &lt;&lt; endl;\ncout &lt;&lt; <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(refer_sales) &lt;&lt; endl;\ncout &lt;&lt; <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(p) &lt;&lt; endl;\ncout &lt;&lt; <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(*p) &lt;&lt; endl;\ncout &lt;&lt; <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(arr) / <span class=\"hljs-built_in\"><span class=\"hljs-keyword\">sizeof</span></span>(*arr) &lt;&lt; endl;\n</code></pre>\n<h2 id=\"1-10-Comma-Operator\"><a href=\"#1-10-Comma-Operator\" class=\"headerlink\" title=\"1.10 Comma Operator\"></a>1.10 Comma Operator</h2><p>comma operator is a <em><strong>binary operator</strong></em>. Its associativity is from left to right.</p>\n<p><em>The real value of comma operator is <strong>value of the expression on the right.</strong></em></p>\n\n    <pre><code class=\"lang-c++\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt;::size_type cnt = ivec.<span class=\"hljs-built_in\">size</span>();\n<span class=\"hljs-keyword\">for</span> (vector&lt;<span class=\"hljs-keyword\">int</span>&gt;::size_type ix = <span class=\"hljs-number\">0</span>; ix != ivec.<span class=\"hljs-built_in\">size</span>(); ++ix, --cnt)\n    ivec[ix] = cnt;\n</code></pre>\n<h2 id=\"1-11-Type-Conversion\"><a href=\"#1-11-Type-Conversion\" class=\"headerlink\" title=\"1.11 Type Conversion\"></a>1.11 Type Conversion</h2><p><strong>implicit conversion: auto, but maybe loss accuracy.</strong></p>\n<p>implicit conversion happens when:</p>\n<ul>\n<li>small <code>int</code> -&gt; larger <code>int</code></li>\n<li>non-bool value -&gt; bool (<em>in conditional expression</em>)</li>\n<li>on the right of assignment operator -&gt; on the left (<em>assignment statement</em>)</li>\n<li>function call</li>\n</ul>\n<h3 id=\"1-11-1-Arithmetic-conversion\"><a href=\"#1-11-1-Arithmetic-conversion\" class=\"headerlink\" title=\"1.11.1 Arithmetic conversion\"></a>1.11.1 Arithmetic conversion</h3><p>Lots of examples:</p>\n\n    <pre><code class=\"lang-c++\">//    <span class=\"hljs-keyword\">some</span> declarations\n<span class=\"hljs-type\">bool</span> flag;\n<span class=\"hljs-type\">char</span> cval;\nshort sval;\nunsigned short usval;\n<span class=\"hljs-type\">int</span> ival;\nunsigned <span class=\"hljs-type\">int</span> uival;\nlong lval;\nunsigned long ulval;\n<span class=\"hljs-type\">float</span> fval;\n<span class=\"hljs-type\">double</span> dval;\n\n//examples\n<span class=\"hljs-number\">3.14159</span>L + <span class=\"hljs-string\">&#x27;a&#x27;</span>;        // long <span class=\"hljs-type\">double</span> + <span class=\"hljs-type\">char</span> (<span class=\"hljs-string\">&#x27;a&#x27;</span> promotes <span class=\"hljs-type\">int</span>, <span class=\"hljs-keyword\">then</span> <span class=\"hljs-type\">int</span> converts long <span class=\"hljs-type\">double</span>)\ndval + ival;        // <span class=\"hljs-type\">double</span> + <span class=\"hljs-type\">int</span> (<span class=\"hljs-type\">int</span> converts <span class=\"hljs-type\">double</span>)\ndval + fval;        // <span class=\"hljs-type\">double</span> + <span class=\"hljs-type\">float</span> (<span class=\"hljs-type\">float</span> converts <span class=\"hljs-type\">double</span>)\nival = dval;        // <span class=\"hljs-type\">int</span> = <span class=\"hljs-type\">double</span> (<span class=\"hljs-type\">double</span> -&gt; <span class=\"hljs-type\">int</span>) (zero-truncation)\nflag = dval;        // <span class=\"hljs-type\">bool</span> = <span class=\"hljs-type\">double</span> (<span class=\"hljs-type\">double</span> -&gt; <span class=\"hljs-type\">bool</span>) (<span class=\"hljs-number\">0</span> -&gt; <span class=\"hljs-keyword\">false</span>, Others -&gt; <span class=\"hljs-keyword\">true</span>)\ncval + fval;        // <span class=\"hljs-type\">char</span> + <span class=\"hljs-type\">float</span> (<span class=\"hljs-type\">char</span> -&gt; <span class=\"hljs-type\">int</span> -&gt; <span class=\"hljs-type\">float</span>)\nsval + cval;        // short + <span class=\"hljs-type\">char</span> (short -&gt; <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">char</span> -&gt; <span class=\"hljs-type\">int</span>)\ncval + lval;        // <span class=\"hljs-type\">char</span> + long (<span class=\"hljs-type\">char</span> -&gt; long)\nival + ulval;        // <span class=\"hljs-type\">int</span> + unsigned long (<span class=\"hljs-type\">int</span> -&gt; unsigned long)\nusval + ival;        // unsigned short + <span class=\"hljs-type\">int</span> (base <span class=\"hljs-keyword\">in</span> sizeof(unsigned short) <span class=\"hljs-keyword\">and</span> sizeof(<span class=\"hljs-type\">int</span>))\nuival + lval;        // unsigned <span class=\"hljs-type\">int</span> + long (base <span class=\"hljs-keyword\">in</span> sizeof(unsigned <span class=\"hljs-type\">int</span>) <span class=\"hljs-keyword\">and</span> sizeof(long))\n</code></pre>\n<h3 id=\"1-11-2-Other-Implicit-Conversion\"><a href=\"#1-11-2-Other-Implicit-Conversion\" class=\"headerlink\" title=\"1.11.2 Other Implicit Conversion\"></a>1.11.2 Other Implicit Conversion</h3><p>Convert array to pointer: <em><strong>In most expressions that use arrays, the array is automatically converted to a pointer to the first element of the array.</strong></em></p>\n<p>Pointer’s convert: constant <code>0</code> and literal value <code>nullptr</code> <strong>can be converted to arbitrary pointer types</strong>; A pointer to any non-constant quantity can be converted into <code>*void </code> ; A pointer to any object can be converted into <code>const void*</code> .</p>\n<p>Arithmetic type to bool type: if the value of arithmetic type / pointer type is zero, the converted result is <code>false</code>, otherwise <code>true</code>.</p>\n<p>Converted into constant: <strong>It is allowed to convert a pointer to non-constant type to a pointer to the corresponding constant type, the same is true for references.</strong> </p>\n\n    <pre><code class=\"lang-c++\"><span class=\"hljs-built_in\">int</span> i;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">int</span> &amp;j = i;\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">int</span> *p = &amp;i;\n<span class=\"hljs-built_in\">int</span> &amp;r = j, *q = p;\n</code></pre>\n<h3 id=\"1-11-3-Explicit-Conversion-cast\"><a href=\"#1-11-3-Explicit-Conversion-cast\" class=\"headerlink\" title=\"1.11.3 Explicit Conversion(cast)\"></a>1.11.3 Explicit Conversion(cast)</h3><p><em>cast-name<type>(expression)</em></p>\n<p><code>static_cast</code>: any well-defined type conversion, as long as it doesn’t contain the <strong>low-level const</strong>, <code>static_cast</code> can be used.</p>\n<p><code>const_cast</code>: only can change low-level const. (<em>cast away the const</em>)</p>\n\n    <pre><code class=\"lang-c++\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">char</span> *pc;\n<span class=\"hljs-keyword\">char</span> *p = <span class=\"hljs-keyword\">const_cast</span>&lt;<span class=\"hljs-keyword\">char</span>*&gt;(pc);\n</code></pre>\n<p><code>reinterpret_cast</code>: no requirement.</p>\n<p>(<em><strong>Attention: avoid explicit conversion.</strong></em>)</p>\n<h2 id=\"Appendix\"><a href=\"#Appendix\" class=\"headerlink\" title=\"Appendix:\"></a>Appendix:</h2><p><img src=\"https://ftp.bmp.ovh/imgs/2021/04/655878eb0d0c4157.png\" alt=\"avatar\"></p>\n","categories":[],"tags":[]}